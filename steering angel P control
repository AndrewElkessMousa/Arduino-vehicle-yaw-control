#define RPWM 6
#define LPWM 7
#define R_EN 4
#define L_EN 5

#define ENC_A 3
#define ENC_B 2

volatile long encoderCount = 0;
volatile int lastEncoded = 0;

const float PPR = (2050.0) * 6;

float Kp = 12;
float Ki = 0;
float Kd = 0;

long targetPosition = 100;

long lastError = 0;
float integral = 0;
unsigned long lastTimePID = 0;

void readEncoder() {
  int MSB = digitalRead(ENC_A);
  int LSB = digitalRead(ENC_B);
  int encoded = (MSB << 1) | LSB;
  int sum = (lastEncoded << 2) | encoded;

  if (sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011)
    encoderCount++;
  if (sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000)
    encoderCount--;

  lastEncoded = encoded;
}

void setup() {
  Serial.begin(9600);

  pinMode(RPWM, OUTPUT);
  pinMode(LPWM, OUTPUT);
  pinMode(R_EN, OUTPUT);
  pinMode(L_EN, OUTPUT);

  pinMode(ENC_A, INPUT);
  pinMode(ENC_B, INPUT);

  digitalWrite(R_EN, HIGH);
  digitalWrite(L_EN, HIGH);

  attachInterrupt(digitalPinToInterrupt(ENC_A), readEncoder, CHANGE);
  attachInterrupt(digitalPinToInterrupt(ENC_B), readEncoder, CHANGE);

  Serial.println("BT7960 PID Position Control Started");
  delay(1000);
}
// Andrew's Loop 
void loop() {
  unsigned long now = millis();
  float dt = (now - lastTimePID) / 1000.0;
  if (dt <= 0) dt = 0.001;

  long scaledPos = encoderCount * (2050.0 / 2001.0);
  long currentPosition = (long)scaledPos;
  long error = targetPosition - currentPosition;

  integral += error * dt;
  integral = constrain(integral, -5000, 5000);

  float derivative = (error - lastError) / dt;

  float output = Kp * error + Ki * integral + Kd * derivative;
  int pwm = constrain(abs(output), 0, 200);

  if (output > 0) {
    analogWrite(RPWM, pwm);
    analogWrite(LPWM, 0);
  } else if (output < 0) {
    analogWrite(RPWM, 0);
    analogWrite(LPWM, pwm);
  } else {
    analogWrite(RPWM, 0);
    analogWrite(LPWM, 0);
  }

  lastError = error;
  lastTimePID = now;

  static unsigned long lastPrint = 0;
  if (now - lastPrint > 200) {
    float degrees = (currentPosition * 360.0) / PPR;
    float targetDeg = (targetPosition * 360.0) / PPR;

    Serial.print("Pos: ");
    Serial.print(currentPosition);
    Serial.print(" (");
    Serial.print(degrees, 1);
    Serial.print("°) | Target: ");
    Serial.print(targetDeg, 1);
    Serial.print("° | PWM: ");
    Serial.println(pwm);

    lastPrint = now;
    Serial.print(derivative);
  }

  delay(1);
}
